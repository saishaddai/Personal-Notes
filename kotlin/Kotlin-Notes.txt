Kotlin Notes


Basic Types: Numbers, Unsigned Numbers, Booleans, Strings, Characters, Arrays
Numbers: Byte, Short, Int, Long, Float, Double
Unsigned: UByte, UShort, UInt, ULong (No UFloat nor UDouble)
Classes: is a blueprint for creating objects that contain data and functions that operate on that data. Classes are the fundamental building blocks of object-oriented programming (OOP) in Kotlin.
Constructors: Primary and Secondary
Primary Constructor: The primary constructor is the main constructor of the class, and it's used to initialize the class properties. The primary constructor is defined using the constructor keyword.
Secondary Constructor: In addition to the primary constructor, a class can have secondary constructors, which are used to provide alternative ways to initialize the class. Secondary constructors are defined using the constructor keyword.
init blocks: a special block of code that is executed when an object is created. It is used to initialize the properties of a class and perform any necessary setup. Used for Initialization, Validation, Setup, Logging
Open Classes: In Kotlin, an open class is a class that can be inherited from. By default, all classes in Kotlin are final, which means they cannot be inherited from. To allow a class to be inherited from, you need to declare it as open using the open keyword
Open methods: an open method is a method that can be overridden by subclasses. By default, all methods in Kotlin are final, which means they cannot be overridden. To allow a method to be overridden, you need to declare it as open using the open keyword.
Abstract classes: an abstract class is a class that cannot be instantiated on its own and is intended to be inherited by other classes. Abstract classes are used to provide a partial implementation of a class that can be shared by multiple subclasses.
Abstract methods: are methods that are declared in an abstract class but do not have an implementation. They must be implemented by any subclass of the abstract class.
Interfaces: an interface is a abstract class that can contain abstract methods and properties. Interfaces are used to define a contract that must be implemented by any class that implements it
Object: In Kotlin, an object is a singleton class that can have properties, functions, and initialization code. Objects are used to create a single instance of a class that can be accessed globally
Java Interfaces VS Kotlin Interfaces
Java abstract classes VS Kotlin Open Classes
companion objects: a companion object is an object that is defined inside a class and is used to provide a way to access a set of related functions and properties. Companion objects are similar to static members in other languages, but they are more powerful and flexible
named companion objects: In Kotlin, you can define a named companion object inside a class to provide a way to access a set of related functions and properties.
Java static final variables vs Kotlin companion objects
SAM Conversions:
Visibility modifiers: public, private, internal, protected
Class Members: public, private, internal, protected
Extensions: is a function that adds functionality to an existing class without modifying the class itself. It's a way to extend the functionality of a class without inheriting from it or modifying its source code
Data Classes: is a special type of class that is used to hold data. It is a concise way to create classes that contain only immutable data and require little to no boilerplate code. It is immutable, concise and data-only
Sealed Classes: a sealed class is a type of class that can be inherited by a fixed set of subclasses. It is used to represent a closed set of alternatives, where the subclasses are known in advance.
Sealed Interfaces:  a sealed interface is a type of interface that can be implemented by a fixed set of classes. It is used to represent a closed set of alternatives, where the implementing classes are known in advance.
Diff Sealed classes and sealed interfaces:Use sealed classes when you need to represent a closed set of alternatives with state. Use sealed interfaces when you need to represent a closed set of alternatives without state. 
Nested Clases: In Kotlin, a nested class is a class that is defined inside another class. Nested classes are also known as inner classes.
Enums and annonimous classes:
Inline Value Classes: @JvmInLine
Delegation: Overriding and use of 'by'
Currying in Kotlin: Currying is a technique in functional programming that allows you to transform a function with multiple arguments into a sequence of functions, each with a single argument. This process enables you to break down a complex function into smaller, simpler functions that can be composed together.
